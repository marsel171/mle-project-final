# Выпускной проект
## Кейс 1: Рекомендации банковских продуктов

## Понимание задачи бизнеса
Современные банки постепенно становятся глобальными экосистемами. Однако мы обратимся к традиционной задаче — предсказать, какие банковские продукты (кредиты, депозиты, инвестиционные продукты) подойдут тем или иным клиентам.
Для банков крайне важно продавать клиентам «правильные продукты». Внедрение рекомендательных систем для предоставления персонализированных рекомендаций реальным и потенциальным клиентам может существенно повлиять на продажи продуктов, увеличивающих оборот и доход.

## Трансляция задачи бизнеса в техническую задачу
Рекомендательные системы помогают предоставить пользователям наиболее релевантные их интересам объекты: товары, развлекательный контент, образовательный материал, профили других пользователей и т. п. Эти пользовательские предпочтения обычно выводятся с помощью оценок элементов. 
В нашей задаче рекомендации банковских продуктов клиенту мы сталкиваемся с несколькими проблемами:
 - отсутствие явных оценок продуктов клиентами для целей рекомендации;
 - проблема холодного старта, затрудняющая рекомендовать продукты потенциальному
или новому клиенту из-за отсутствия информации о предпочтениях и оценках клиента;
 - достаточно ли алгоритму будет сравнения по 20-30 продуктам (будет ли эффективен в таких условиях ALS-алгоритм).
В текущей реализации будет использован гибридный подход, который сочетает в себе решение задачи ранжирования (ALS-алгоритм), задачи кластеризации (K-means), а также решение задачи многоклассовой классификации.

## Цель
Предсказать, какой банковский продукт предложить клиенту.

### Исходные данные
Первичные данные находятся в одном файле `train_ver2.csv`.
Описание данных:
```
fecha_dato	Колонка для разделения таблицы
ncodpers	Идентификатор пользователя
ind_empleado	Статус занятости:
- A — трудоустроен
- B — безработный, раньше работал
- F — иждивенец
- N — безработный
- P — пассивный (статус не определён)
pais_residencia	Страна резидентства
sexo	Пол
age	Возраст
fecha_alta	Дата, когда клиент впервые заключил договор в банке
ind_nuevo	1, если клиент зарегистрировался за последние 6 месяцев
antiguedad	Стаж клиента (в месяцах)
indrel	1 — первичный клиент
99 — первичный клиент в течении месяца, но не в конце
ult_fec_cli_1t	Последняя дата, когда клиент был премиальным
indrel_1mes	Тип клиента в начале месяца:
- 1 — премиальный
- 2 — собственник
- P — потенциальный
- 3 — раньше был премиальным
- 4 — раньше был собственником
tiprel_1mes	Тип клиента в начале месяца:
- A — активный
- I — неактивный
- P — бывший
- R — потенциальный
indresi	Если страна проживания совпадает со страной банка
indext	Если страна рождения клиента отличается от страны банка
conyuemp	1, если клиент супруг(а) работника
canal_entrada	Канал, по которому пришел пользователь
indfall	Индекс актуальности счёта (англ. Deceased index, N/S)
tipodom	Тип адреса (1 — основной адрес)
cod_prov	Код провинции (адреса клиента)
nomprov	Имя провинции
ind_actividad_cliente	Активность пользователя (1 — активный, 0 — неактивный)
renta	Доход домохозяйства
segmento	Сегментация: 1 — VIP, 2 — Обыкновенные 3 — выпускники колледжей
ind_ahor_fin_ult1	Сберегательный счёт
ind_aval_fin_ult1	Банковская гарантия
ind_cco_fin_ult1	Текущие счета
ind_cder_fin_ult1	Деривативный счёт
ind_cno_fin_ult1	Зарплатный проект
ind_ctju_fin_ult1	Детский счёт
ind_ctma_fin_ult1	Особый счёт 3
ind_ctop_fin_ult1	Особый счёт
ind_ctpp_fin_ult1	Особый счёт 2
ind_deco_fin_ult1	Краткосрочный депозит
ind_deme_fin_ult1	Среднесрочный депозит
ind_dela_fin_ult1	Долгосрочный депозит
ind_ecue_fin_ult1	Цифровой счёт
ind_fond_fin_ult1	Денежный средства
ind_hip_fin_ult1	Ипотека
ind_plan_fin_ult1	Пенсионный план
ind_pres_fin_ult1	Кредит
ind_reca_fin_ult1	Налоговый счёт
ind_tjcr_fin_ult1	Кредитная карта
ind_valo_fin_ult1	Ценные бумаги
ind_viv_fin_ult1	Домашний счёт
ind_nomina_ult1	Аккаунт для выплаты зарплаты
ind_nom_pens_ult1	Аккаунт для пенсионных обязательств
ind_recibo_ult1	Дебетовый аккаунт
```

## Основные задачи 
 - Анализ данных о клиентах 
 - Определение важных метрик
 - Моделирование
 - Продуктивизация модели
 - Настройка мониторинга и дообучения
 - Данные: Ссылка на датасет

## Необходимая нфраструктура для обучения модели
MLFlow/S3

## Шаги и результаты
```
1. Исследование данных. 

Проведен первичный анализ данных в Jupyter Notebook и описаны увиденные в них закономерности.	

  - Jupyter Notebook с EDA: recommendations_EDA.ipynb. 
  - Папка с графиками: assets.
  - Папка с данными: data.
  - Результаты описаны в конце ноутбука, а также после каждого исследования признаков в ячейках.
  - Таблицы загружены в хранилище S3, а артефакты в MLflow.

Этапы работ в ноутбуке включают в себя:

    I. Исследование и анализ данных о клиентах (загрузка первичных данных, описание, обзор, проверка проблем в персональных данных клиентов и в данных о продуктах, исправление проблем).

    По итогу анализа были сделаны следующие выводы (более подробная информация есть в ноутбуке):
    Портрет пользователя банка:
    - Безработный испанец(ка), живущий в Испании (большая вероятность, что из Мадрида). 
    - Возраст 25 лет (Выпускник колледжа, маленький стаж) и 50 лет (Обыкновенный, большой стаж). 
    - Доход 70,000.
    - Пользуются продуктами банка больше 6 месяцев.
    - Половина из них Активно пользуются банком, половина - неактивно.
    По популярности банковских продуктов:
    - Самым массовым банковским продуктом является "Текущие счета". Его оформляли 7975656 раз, что составляет 68% из числа всех взаимодействий. 
    - Также 67% пользователей хотя бы раз пользовались этим продуктом.
    - Возраст пользователя, который пользуется этим продуктом: небольшой перевес в сторону молодого поколения (61%). 
    - По полу и активности - одинаково.

    II. EDA. Построены графики:

     - по динамике пользователей и событий по месяцам (data/1_events_by_months.png); 
     - популярности продуктов (data/2_features_by_products.png);  
     - распределение клиентов по возрасту и полу (data/3_age_vs_sexo.png); 
     - распределение клиентов по активности и полу (data/4_age_vs_actividad.png); 
     - распределение по длительности пользования банковскими продуктами (data/5_duration_of_use.png).

    III. Сохранение данных:

     - очищенный датасет и остальные таблицы сохранены в формате parquet в папке data/ (на локале).
     - все таблицы загружены в S3 в папку final_project/data/.
     - артефакты (ноутбук и графики, а также некотореы таблицы) залогированы в MLflow в 
        EXPERIMENT_NAME = "marselkamilov_final_project"
        RUN_NAME = "EDA"
        🏃 View run EDA at: http://127.0.0.1:5000/#/experiments/78/runs/f119e86eead749a1a24fcb6097cf7ce8
        🧪 View experiment at: http://127.0.0.1:5000/#/experiments/78


2. Подготовка инфраструктуры. 

Развернут MLflow с хранилищем артефактов.	
 - sh-скрипт с запуском и настройкой MLflow: run_mlflow_server.sh.
 - запуск: sh run_mlflow_server.sh.
 - переменные окружения загружаются из .env.


3. Трансляция. 

Для решения нашей задачи был выбран следующий подход и метрики:
Оталкиваясь от исследований в этой области было решено строить алгоритм рекомендательной системы банковских продуктов
на основе гибридного подхода, которая сочетает метод коллаборативной фильтрации (ALS) и демографический подход.

Этапы построения алгоритма РС:

   I. Построение ALS-алгоритма: 

    - Построение UI-матрицы «клиенты-продукты» для каждого клиента на основе неявной оценки продукта по определенной шкале в зависимости
от частоты использования этого банковского продукта; 
    - Прогнозирование оценки еще не оцененных продуктов на основе item-based;

   II. Построение алгоритма по демографическому подходу: 

    - Группировка пользователей в кластеры на основе демографических
данных, такие как (возраст, пол, доход, активность, стаж и место жительства) с применением алгоритма k-средних;
    - Построение матрицы «кластеры-продукты», содержащей среднее значение оценок, присвоенных продукту всеми клиентами в кластере.

   III. Объединение базовых алгоритмов: 

    - Получение прогнозов по обоим алгоритмам, объединение и сортировка рейтингов в порядке убывания и рекомендация клиенту первых N продуктов.

Разбиение данных:

 - Данные разделяются на обучающий и тестовый набор по глобальному разделению по времени (Global Time Split, Temporal Global). Выбирается одна точка во времени ts: все события до неё входят в тренировочную выборку (прошлое), после неё — в тестовую (будущее). 
 - На основе обучающего набора формируется UI-матрица и матрица «продукты—кластеры».
 - Для формирования тестового набора выбираются клиенты как минимум с тремя продуктами в наборе данных с оценками продуктов.

Метрики:

Выбрана метрика ранжирования NDCG@5, поскольку мы решаем задачу ранжирования и используем алгоритмом ALS. Она принимает значение от 0 (предлагаемый порядок никак не соответствует истинному) до 1 (предлагаемый порядок в точности соответствует истинному). 
    

4. Моделирование. 

Проведите эксперименты. Подготовьте пайплайн обработки данных и построения модели.	
 - Jupyter Notebook с проведением экспериментов, bin-файл модели.


5. Продуктивизация. 

Оберните модель в веб-сервис, чтобы она отвечала на запросы по API. Также сервис должен подниматься в Docker для удобства выкатки.	
 - Python-проект с описанным Dockerfile и описанной структурой API.


6. Мониторинг. 

Проследите, чтобы все сервисы в продакшен-среде контролировались метриками.	
 - .md-файл с описанием метрик. Метрики должны отправляться из кода проекта.


7. Документация. 

Самая важная часть — опишите процесс обработки данных, создания модели, её выкатки и сопровождения.	
 - Заполненный ReadMe.md


8. Требования и среда.

Зафиксируйте случайные состояния и приложите зависимости, с которыми вы работали в рамках прокта. Важно соблюсти воспроизводимость экспериментов.	
 - Сформированный файл requirements.txt
```


### Файлы с рекомендациями:

 - топ популярных — в `top_popular.parquet`
 - персональные (при помощи ALS) — в `personal_als.parquet`
 - похожие треки (i2i при помощи ALS) — в `similar.parquet`
 - итоговые рекомендации — в `recommendations.parquet`


## Сервис рекомендаций
Код сервиса находится в файле `recommendations_service.py`.

Необходимые библиотеки описаны в `requirements.txt`

### Необходимые шаги для запуска сервиса рекомендаций:
 - Запуск из командной строки в папке с кодом:

    `uvicorn recommendations_service:app`

 - Сервис поднимается по адресу http://127.0.0.1:8000 (по умолчанию)
 
 - Описание эндпоинтов сервиса:
    
    `/recommendations` - Основной метод, который принимает запрос с идентификатором пользователя `user_id` и выдаёт рекомендации, учитывая историю пользователя и смешивая онлайн- и офлайн-рекомендации.

    `/get_online_u2i` - Возвращает список онлайн-рекомендаций по k-последним событиям пользователя `user_id`, и по N-похожим трекам на каждое событие. Рекомендации генерируются обученной в ноутбуке моделью ALS (`als_model.npz`), которая загружается при запуске сервиса. Треки предварительно кодируются из `track_id` в `track_id_enc` и потом обратно энкодируются. Для этих целей при запуске сервиса подгружается файл `items.parquet`, в котором хранятся закодированные идентификаторы треков.

    `/put_user_event` - Сохраняет событие для `user_id`, `item_id`.

    `/get_user_events` - Возвращает список последних k событий для пользователя `user_id`.


    `/load_recommendations` - Загружает оффлайн-рекомендации из файла (на случай, если файлы рекомендаций обновились).


    `/get_statistics` - Выводит статистику по имеющимся счётчикам.


## Инструкции для тестирования сервиса

Код для тестирования сервиса находится в файле `test_service.py`.

### Необходимые шаги для тестирования сервиса рекомендаций

 - Запрос на получение ответа от сервиса рекомендаций:
    
    1) Для пользователя `user_id = 47` отправляется POST-запрос по адресу
    
        'http://127.0.0.1:8000/recommendations'

        Получим персональные рекомендации (в консоли видим "Found 100 personal recommendations!"):
        
        `{'recs': [977, 975, 973, 971,...}`

    2) Для "холодного" пользователя `user_id = 47000000000` 

        получим ТОП-рекомендации (в консоли видим "Found 100 TOP-recommendations!"):
        
        `{'recs': [47627256, 51516485, 24692821, 32947997, 55561798,...} `

 - Запрос на вывод статистики:

    отправляется GET-запрос по адресу
    
    'http://127.0.0.1:8000/get_statistics'

    получим:

    `{'request_personal_count': 1, 'request_default_count': 1}`

 - Запрос на события:

    1) Убедимся, что вначале нет событий для пользователя `user_id = 16` 
    
        'http://127.0.0.1:8000/get_user_events'
        
        получим:

        `{'events': []}`

    2) Добавим событий событий в цикле для того же пользователя `user_id = 16` 
    
        'http://127.0.0.1:8000/put_user_event'

        679169 - [Thunderstruck] [AC/DC]	
        630670 - [You're Gonna Go Far, Kid] [The Offspring]	
        646516 - [Chop Suey!] [System of A Down]	
        19152669 - [Centuries] [Fall Out Boy]
        38646012 - [Another Brick In The Wall, Pt. 2] [Pink Floyd]
        
        получим:
        
        679169
        {'result': 'ok'}

        630670
        {'result': 'ok'}

        646516
        {'result': 'ok'}

        19152669
        {'result': 'ok'}

        38646012
        {'result': 'ok'}

    3) Убедимся, что эти события появились для пользователя `user_id = 16` 
    
        'http://127.0.0.1:8000/get_user_events'
        
        получим:
        
        {'events': [38646012, 19152669, 646516, 630670, 679169, 679169]}

 - Запрос на получение итоговых (смешанных) рекомендаций для пользователя `user_id = 16`
    
        'http://127.0.0.1:8000/recommendations'
        
        получим:
        
        {'recs': [672687, 2278985, 647040, 3616433, 654151, 630670, 694683, 10270285,...}

        А список треков выглядит так:

        online rec track name:  ['Toxicity']
        online rec artist name:  ['System of A Down']
        online rec track name:  ['Rolling In The Deep']
        online rec artist name:  ['Adele']
        online rec track name:  ['Back in Black']
        online rec artist name:  ['AC/DC']
        online rec track name:  ['Summertime Sadness']
        online rec artist name:  ['Lana Del Rey']
        online rec track name:  ["The Kids Aren't Alright"]
        online rec artist name:  ['The Offspring']
        online rec track name:  ["You're Gonna Go Far, Kid"]
        online rec artist name:  ['The Offspring']
        online rec track name:  ['Highway to Hell']
        online rec artist name:  ['AC/DC']
        online rec track name:  ['Young And Beautiful']
        online rec artist name:  ['Lana Del Rey']
        и т.д.

### ВЫВОДЫ:

    Рекомендации выглядят отлично!
    Микросервис успешно принимает запросы с идентификатором пользователя и возвращает рекомендации. 
    Учтена история пользователя при выдаче рекомендаций. 
    Описана стратегия смешивания онлайн- и офлайн-рекомендаций в README. 
    Проведено тестирование микросервиса для разных типов пользователей, код оформлен в test_service.py.


 
